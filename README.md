Complex queries can be written with normal SQL, including the values needs to be bound and prefixed with the `sql` tag.

The package is highly inspired by [slonik](https://www.npmjs.com/package/slonik) and the article having a critical look at [knex](https://www.npmjs.com/package/knex):

https://medium.com/@gajus/stop-using-knex-js-and-earn-30-bf410349856c

Special thanks to [gajus](https://github.com/gajus).

Also it's more a research than a production ready package to understand the concepts behind in deep and get more experience in working effectively with SQL.

# Initialization

```javascript
const sql = require('sql-pg')
sql.client = client // optional, but needed for ".query()", ".select()", ".insert()", ".update()", ".delete()", ".transaction()"
```

# Syntax Highlighting

## Atom

1. Install `language-babel` package
2. In the settings of this package search for "JavaScript Tagged Template Literals Grammar Extensions" and add the support for SQL via `sql:source.sql`
3. If it doesn't work disable "Use Tree Sitter Parsers" in the core settings

# Alternative databases

* MySQL: [sql-mysql](https://www.npmjs.com/package/sql-mysql)

# Examples using the methods

## Select

The return value is `result.rows` of the pg result object.

### All columns

```javascript
const rows = await sql.select(
  'users',
  { email: 'email', passwordhash: 'passwordhash' }
)

// text: SELECT "*" FROM "users" WHERE "email" = $1 AND "passwordhash" = $2
// parameters: ['email', 'passwordhash']
```

### Only the list of the given columns

```javascript
const rows = await sql.select(
  'users',
  ['id', 'active'],
  { email: 'email', passwordhash: 'passwordhash' }
)

// text: SELECT "id", "active" FROM "users" WHERE "email" = $1 AND "passwordhash" = $2
// parameters: ['email', 'passwordhash']
```

## Insert

### Single row (rows is an object)

The return value is the SERIAL generated by inserting the new row located in `result.rows[0][serialColumn = 'id']` of the pg result object.

```javascript
const id = await sql.insert(
  'users',
  { email: 'email', passwordhash: 'passwordhash' }
)

// text: INSERT INTO "users" ("email", "passwordhash") VALUES ($1, $2) RETURNING "id"
// parameters: ['email', 'passwordhash']
```

### Multiple rows (rows is an array of objects)

The return value is an array of the SERIALs generated by inserting the new row located in `result.rows[][serialColumn = 'id']` of the pg result object.

```javascript
const ids = await sql.insert(
  'users',
  [
    { email: 'emailA', passwordhash: 'passwordhashA' },
    { email: 'emailB', passwordhash: 'passwordhashB' },
    { email: 'emailC', passwordhash: 'passwordhashC' }
  ]
)

// text: INSERT INTO "users" ("email", "passwordhash") VALUES ($1, $2), ($3, $4), ($5, $6) RETURNING "id"
// parameters: ['emailA', 'passwordhashA', 'emailB', 'passwordhashB', 'emailC', 'passwordhashC']
```

The return value is also an array if the given `rows` array contains only one object. It only depends on the datatype of `rows`.

### Returning another serial column

```javascript
const example = await sql.insert(
  'users',
  { email: 'email', passwordhash: 'passwordhash' },
  'example'
)

// text: INSERT INTO "users" ("email", "passwordhash") VALUES ($1, $2) RETURNING "example"
// parameters: ['email', 'passwordhash']
```

## Update

The return value is the count of the rows affected by the update located in `result.rowCount` of the pg result object.

```javascript
const rowCount = await sql.update(
  'users',
  { email: 'new email', passwordhash: 'new passwordhash' },
  { email: 'old email', passwordhash: 'old passwordhash' }
)

// text: UPDATE "users" SET "email" = $1, "passwordhash" = $2 WHERE "email" = $3 AND "passwordhash" = $4
// parameters: ['new email', 'new passwordhash', 'old email', 'old passwordhash']
```

## Delete

The return value is the count of the rows affected by the delete located in `result.rowCount` of the pg result object.

```javascript
const rowCount = await sql.delete(
  'users',
  { email: 'email', passwordhash: 'passwordhash' }
)

// text: DELETE FROM "users" WHERE "email" = $1 AND "passwordhash" = $2
// parameters: ['email', 'passwordhash']
```

## Transaction

It's possible to wrap multiple queries into a transaction which will be started and at the end committed. If an error is thrown, the transaction will be rollbacked.

```javascript
await client.transaction(async () => {
  const email = 'email'
  const id = await sql.insert(
    'users',
    { email, passwordhash: 'passwordhash' }
  )
  await client.insert(
    'audits',
    { type: 'user registration', message: `user with e-mail "${email}" is registered with the ID ${id}` }
  )
})
```

# Examples using the SQL tagged template literal and tag helpers

Alternatively to `sql.query()` also the `client.query()` of `pg` can be used. The downside is the missing check the given parameter is a SQL tagged template literal. A missing SQL tag can open the doors for SQL injection.

## Extract and bind values

```javascript
const email = 'email'
const passwordhash = 'passwordhash'

const result = await sql.query(sql`
  SELECT * FROM users WHERE email = ${email} AND passwordhash = ${passwordhash}
`)

// text: SELECT * FROM users WHERE email = $1 AND passwordhash = $2
// parameters: ['email', 'passwordhash']
```

## Escape keys for tables and columns

```javascript
const table = 'users'
const columns = ['id', 'email']

const result = await sql.query(sql`
  SELECT ${sql.keys(columns)} FROM ${sql.key(table)}
`)

// text: SELECT "id", "email" FROM "users"
// parameters: []
```

If the parameter is an object (e.g. a user) the keys of the object will be used:

```javascript
const user = { id: 'id', email: 'email' }

const result = await sql.query(sql`
  SELECT ${sql.keys(user)} FROM users
`)

// text: SELECT "id", "email" FROM "users"
// parameters: []
```

## Support list of values

```javascript

const values = ['email', 'passwordhash']

const result = await sql.query(sql`
  INSERT INTO users (email, passwordhash) VALUES (${sql.values(values)})
`)

// text: INSERT INTO users (email, passwordhash) VALUES ($1, $2)
// parameters: ['email', 'passwordhash']
```

If the parameter is an object (e.g. a user) the values of the object will be used:

```javascript
const user = { email: 'email', passwordhash: 'passwordhash' }

const result = await sql.query(sql`
  INSERT INTO users (email, passwordhash) VALUES (${sql.values(user)})
`)

// text: INSERT INTO users (email, passwordhash) VALUES ($1, $2)
// parameters: ['email', 'passwordhash']
```

## Support multiple list of values

```javascript
const valuesList = [
  ['emailA', 'passwordhashA'],
  ['emailB', 'passwordhashB']
]

const result = await sql.query(sql`
  INSERT INTO users (email, passwordhash) VALUES ${sql.values(valuesList)}
`)

// text: INSERT INTO users (email, passwordhash) VALUES ($1, $2), ($3, $4)
// parameters: ['emailA', 'passwordhashA', 'emailB', 'passwordhashB']
```

If the parameter is an array of objects (e.g. list of users) the values of the objects will be used:

```javascript
const users = [
  { email: 'emailA', passwordhash: 'passwordhashA' },
  { email: 'emailB', passwordhash: 'passwordhashB' }
]

const result = await sql.query(sql`
  INSERT INTO users (email, passwordhash) VALUES ${sql.values(users)}
`)

// text: INSERT INTO users (email, passwordhash) VALUES ($1, $2), ($3, $4)
// parameters: ['emailA', 'passwordhashA', 'emailB', 'passwordhashB']
```

## Support assignments for updates

```javascript
const user = { email: 'email', passwordhash: 'passwordhash' }

const result = await sql.query(sql`
  UPDATE users SET ${sql.assignments(user)} WHERE id = 'id'
`)

// text: UPDATE users SET ("email", "passwordhash") = ($1, $2) WHERE id = 'id'
// parameters: ['email', 'passwordhash']
```

## Support pairs of column keys and values using as alternative of assignments for updates

```javascript
const user = { email: 'email', passwordhash: 'passwordhash' }

const result = await sql.query(sql`
  UPDATE users SET ${sql.pairs(user, ', ')} WHERE id = 'id'
`)

// text: UPDATE users SET "email" = $1, "passwordhash" = $2 WHERE id = 'id'
// parameters: ['email', 'passwordhash']
```

## Support conditions for basic use cases

```javascript
const user = { email: 'email', passwordhash: 'passwordhash' }

const result = await sql.query(sql`
  SELECT * FROM users WHERE ${sql.conditions(user)}
`)

// text: SELECT * FROM users WHERE "email" = $1 AND "passwordhash" = $2
// parameters: ['email', 'passwordhash']
```

## Support pairs of column keys and values using as alternative of conditions

```javascript
const user = { email: 'email', passwordhash: 'passwordhash' }

const result = await sql.query(sql`
  SELECT * FROM users WHERE ${sql.pairs(user, ' AND ')}
`)

// text: SELECT * FROM users WHERE "email" = $1 AND "passwordhash" = $2
// parameters: ['email', 'passwordhash']
```

## Support for nested queries

```javascript
const state = 'active'
const email = 'email'
const passwordhash = 'passwordhash'

const result = await sql.query(sql`
  SELECT * FROM users WHERE
    state = ${state}
    AND
    id = (${sql`SELECT id FROM users WHERE email = ${email} AND passwordhash = ${passwordhash}`})
`)

// text: SELECT * FROM users WHERE
//         state = $1
//         AND
//         id = (SELECT id FROM users WHERE email = $2 AND passwordhash = $3)
// parameters: ['active', 'email', 'passwordhash']
```

## Support for limit, offset and pagination

```javascript
const actualLimit = 10
const maxLimit = 50
const offset = 20

const result = await sql.query(sql`
  SELECT * FROM users ${sql.limit(actualLimit, maxLimit)} ${sql.offset(offset)}
`)

// text: SELECT * FROM users LIMIT 10 OFFSET 20
// parameters: []
```

`maxLimit` is optional, but it should be set with a non user defined number to ensure a user can't select an infinite number of rows.

Because of pagination is a common use case there is also a pagination shorthand:

```javascript
const page = 5
const pageSize = 10

const result = await sql.query(sql`
  SELECT * FROM users ${sql.pagination(page, pageSize)}
`)

// text: SELECT * FROM users LIMIT 10 OFFSET 50
// parameters: []
```

# Extend with own tag helpers

It's possible to define own fragment methods by adding them to the `sql` tag:

```javascript
const bcrypt = require('bcrypt')

sql.passwordhash = (password, saltRounds = 10) => parameterPosition => ({
  text: `$${++parameterPosition}`,
  parameters: [bcrypt.hashSync(password, saltRounds)]
})

const user = { email: 'email' }
const password = 'password'

const result = await sql.query(sql`
  INSERT INTO users (email, passwordhash) VALUES (${sql.values(user)}, ${sql.passwordhash(password)})
`)

// text: INSERT INTO users (email, passwordhash) VALUES ($1, $2)
// parameters: ['email', '$2b$10$ODInlkbnvW90q.EGZ.1Ale3YpOqqdn0QtAotg8q/JzM5HGky6Q2j6']
```

It's also possible to reuse existing fragments methods to define own ones:

```javascript
const bcrypt = require('bcrypt')

sql.passwordhash = (password, saltRounds = 10) => sql.values([bcrypt.hashSync(password, saltRounds)])

const user = { email: 'email' }
const password = 'password'

const result = await sql.query(sql`
  INSERT INTO users (email, passwordhash) VALUES (${sql.values(user)}, ${sql.passwordhash(password)})
`)

// text: INSERT INTO users (email, passwordhash) VALUES ($1, $2)
// parameters: ['email', '$2b$10$ODInlkbnvW90q.EGZ.1Ale3YpOqqdn0QtAotg8q/JzM5HGky6Q2j6']
```

If no parameter bindings needed, the shorthand can be used by returning directly the result object:

```javascript
sql.active = active => ({
  text: active ? 'active = true' : '1',
  parameters: []
})

const active = true

const result = await sql.query(sql`
  SELECT * FROM users WHERE ${sql.active(active)}
`)

// text: SELECT * FROM users WHERE active = true
// parameters: []
```

Or by define a constant result object if no parameters needed:

```javascript
sql.first = {
  text: `LIMIT 1`,
  parameters: []
}

const result = await sql.query(sql`
  SELECT * FROM users ${sql.first}
`)

// text: SELECT * FROM users LIMIT 1
// parameters: []
```
